\section{Asynchrone Programmierung in Clojure}

Clojure ist eine Sprache, die zur Java-Bytecode, CIL-Bytecode oder JavaScript (\acl{CLJS}) compiliert werden kann und somit von einer \ac{JVM}, \ac{CLR} oder einem JavaScript-Interpreter ausgeführt werden können.

In den beiden ersten Laufzeitumgebungen können Threads, für die asynchrone und gleichzeitige Verarbeitung von Befehlen verwendet werden und in JavaScript gibt es den im vorherigen Kapitel vorgestellten Event-Handler.

Das folgende Beispiel und alle restlichen Erläuterungen und Beispiele beziehen sich auf Clojure in Verwendung mit einer \ac{JVM}.
\comment{Etwas mehr auf Threads eingehen}

\subsection*{Beispiel mit der Methode \textit{future}}
Die einfachste Methode eine Aufgabe auszulagern, die dann asynchron und concurrent abgearbeitet wird, funktioniert über die \textit{future}-Methode, wie in dem Beispiel in Listing \ref{lst:clojure_future} zu sehen ist. Die Methode übergibt den übergebenen Body an einen einen Thread in einem \textit{ExecutionService} und gibt ein Future-Objekt an den Hauptthread zurück.

Der Hauptthread kann nun weiterlaufen und weitere Aufgaben erledigen. Im Beispiel testet der Hauptthread noch ob es sich um ein Future handelt und mit der der Methode \textit{realized?} prüft er, ob bereits ein Ergebnis vorliegt. Wenn der andere Thread nun fertig ist, kann der Hauptthread das Ergebnis der Berechnung über das Future anfragen, indem er \textit{@} das Objekt dereferenziert. Falls der Thread nicht fertig ist, blockiert der Hauptthread solange bis das Ergebnis vorliegt.

\begin{lstlisting}[language=Clojure,caption=Das asynchrone Ausführen von Befehlen mit der Methode \textit{future},label=lst:clojure_future]
(println (-> (Thread/currentThread) (.getName)))
(let [f (future
          (Thread/sleep 1000)
          (println (-> (Thread/currentThread) (.getName)) "I am done")
          42)]
  (println (future? f))
  (println (realized? f))
  (Thread/sleep 2000)
  (println (realized? f))
  (println @f))
...
[stdout]:nREPL-worker-7
[stdout]:true
[stdout]:false
[stdout]:clojure-agent-send-off-pool-9 I am done
[stdout]:true
[stdout]:42
\end{lstlisting}

Dieses Beispiel verdeutlicht die sehr einfache Verwendung in Clojure. Falls eine gezieltere Kontrolle über die Definition und Ausführung von Threads gefordert ist, kann über die \textit{Java-Interop}-Schnittstelle Threads selbstständig definiert werden oder es kann das \textit{ExecutionService}-Framework verwendet werden.

\subsection*{\acl{STM}}
Bei der gleichzeitigen Verarbeitung von Aufgaben und der Benutzung eines \textit{Shared Storages} gibt immer die Problematik, dass \textit{Race Conditions} entstehen können und Objekte inkonsistent werden können.

In Clojure sollte dementsprechend bei der Bearbeitung von Referenzen ein \acf{STM}, das die Inkonsistenz mittels \ac{MVCC} verhindert. Das Phänomen des \textit{Write Skew} muss aber aber vom Entwickler erkannt und besonders behandelt werden.
\comment{Write Skew erklären im Glossar vielleicht?}

Falls kein \ac{STM} erwünscht ist, kann auch das Locking von Java mit Sperren verwendet werden, wenn die Methode \textit{locking} verwendet wird.
