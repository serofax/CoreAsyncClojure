\section{Asynchrone Programmierung in Clojure}




\comment{Alle Sektionen hier drunter läschen}
\section{Asynchrone Programmierung in Java}
Die einzige Möglichkeit von Haus aus in Java asynchron Befehle auszuführen geht über Threads.

Die Java-Platform bietet hierzu verschiedene Möglichkeiten an, um die Threads einfach zu handhaben. Beispiele dafür sind \textit{Executor}-Framework, \textit{Future}s oder die gerne in der \acs{GUI}-Programmierung verwendeten Callbacks (\textit{Listener}).

\subsection{Threads}

\begin{lstlisting}[language=Java,caption=Definition und Erzeugung eines Threads,label=lst:java_thread]
public class Worker implements Runnable {
	public void run(){
		//Do something asynchronous 	
	}
}
...
gatherInformation();
new Thread(new Worker()).start(); 
continueWork();
\end{lstlisting}


\subsection{ExecutionServices}

\begin{lstlisting}[language=Java,caption=Verwendung eines ExecutionServices,label=lst:java_executionservice]
ExecutorService es = Executors.newFixedThreadPool(2);
gatherInformation();
es.execute(new Worker())
continueWork();
\end{lstlisting}

ForkJoinPool für Rekursive Tasks

\subsection{Callbacks und Futures}
\comment{Callbacks bei UI werden asynchron , bzw später ausgeführt.}
\begin{lstlisting}[language=Java,caption=Verwendung von Futures,label=lst:java_futures]
public class Task implements Callable<Integer> {
	public Integer call(){
		//Do something asynchronous
		return 42; 	
	}
}
...
ExecutorService es = Executors.newFixedThreadPool(2);
gatherInformation();
Future<Integer> f = es.submit(new Task())
continueWork();
...
System.out.println("meaning of life: " + f.get());


\end{lstlisting}
Beide bringen das Ergebnis zurück

\comment{Hier auch Futures erklären}

\subsection{JCSP}

\subsection{Brainstorming}
JCSP, Future, Callback, ExecutionService (bzw nur Executor), Threads
