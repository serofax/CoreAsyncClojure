\section{\acl{CSP}}
\acf{CSP} ist eine von \textit{C.A.R. Hoare} in seinem Paper\footcite{CSP} \textit{Communication Sequential Processes} 1978 erstmals vorgestellte formale Modellierung von nebenläufigen Prozessen und deren Kommunikation untereinander mit Events und Nachrichten.

Als Begründung, warum er ein solches System definiert hat, gibt Hoare an, dass in Zukunft neue Algorithmen benötigt werden, die parallel ausgeführt werden. Durch die zwingende Kommunikation unter den Prozessen ist ein neues Konzept von Nöten, dass das genau spezifiziert und somit die  Effizient steigert. Die damalige Synchronisation über \textit{shared Storage} hat ihm nicht gefallen, da sie zu fehleranfällig und zu komplex war.\footcite[Introduction]{CSP}

Die verwendeten Symbole werden von \textit{C.A.R. Hoare} in seinem Buch\footcite[Glossary of Symbols]{CSPBOOK} beschrieben und können da nachgeschlagen werden.
\subsection[Operatoren und Konstrukte in \acs{CSP}]{Operatoren und Konstrukte in \acs{CSP}\footcite[Siehe][Kap. 1.1]{CSPBOOK}}

Hoare definiert sehr viele Operatoren und Konstrukte. Die Essentiellen von ihren werden nun erläutert. Für Beispiele, wird das von Hoare gerne in seinem Buch\footcite{CSPBOOK} verwendete Beispiel eines Schokoladenautomaten verwendet, jedoch wurden die Begriffe ins Deutsche übersetzt.

\subsubsection{Events}
Events sind Aktionen, die auftreten können. Zwischen eingehenden und ausgehenden Events wird nicht unterschieden. In Hoares Notation werden Events in Kleinbuchstaben geschrieben.
Zum Beispiel bei einem einfachen Schokoladenautomaten gäbe es folgende Events:

\begin{addmargin}[1cm]{0cm}
münze - Das Einwerfen einer Münze in den Automaten.\\
schokolade - Das Entnehmen der Schokolade aus dem Auswurf des Automaten.
\end{addmargin}

Um den Bezug zu \CA\ herzustellen, erweitern wir die Events um Channels, womit sich Hoare erst in einem späteren Kapitel\footcite[Kap. 4.2]{CSPBOOK} im Buch befasst. Stellen wir uns nun den Münzeinwurf (\textit{in}) und den Auswurf (\textit{out}) des Automaten als Channel vor. Die Events aus Sicht des Prozesses sehen nun wie folgt aus:

\begin{addmargin}[1cm]{0cm}
in.münze - Das Entnehmen einer Münze aus dem Münzeinwurf.\\
out.schokolade - Das Hineinlegen einer Schokolade in den Auswurf.
\end{addmargin}

Um Variablen ins Spiel zu bringen gibt es den ?-Operator und den !-Operator. Da das Beispiel dafür ungeeignet ist, wird ein Neues definiert. Nun gibt es einen Automaten (\textit{COPY}), der aus seinem in-Channel liest und den Wert in seinen out-Channel schreibt. Folgende Events gäbe es:

\begin{addmargin}[1cm]{0cm}
in?x - Das Entnehmen von Irgendwas aus dem in-channel und das Speichern in der Variable x.\\
out!x - Das Hineinlegen von dem Wert in der Variable x auf den out-channel.
\end{addmargin}

Alle weiteren Konstrukte werden anhand von Channels erklärt.

\subsubsection{Prozesse}
Ein Prozess definiert sich durch eine Kombination aus verschiedenen Events, die sequentiell hintereinander ausgeführt werden. In unserem ersten Beispiel existiert nur ein Prozess und zwar der Schokoladenautomat \textit{SA}, der durch die Großbuchstaben auch als solches erkenntlich ist. Um einen Automaten terminierbar darzustellen kann nicht einfach nach einem Event nichts mehr folgen, da das die Notation nicht vorsieht. Nach einem Event muss immer ein Prozess oder ein weiteres Event kommen. Deswegen wird hierzu ein Prozess \textit{STOP} definiert, der nach der eigentlichen Ausführung kommt. Er symbolisiert, dass der Schokoladenautomat nicht mehr funktioniert.

\subsubsection{Verkettung}
Um Events, Prozesse und andere Konstrukte sequentiell auszuführen kann $ (\text{in.münze} \rightarrow (out.schokolade \rightarrow STOP)) $ geschrieben werden. Diese Ausführung beschreibt einen Schokoladenautomaten, der eine Münze annimmt und Schokolade auswirft und dann nicht mehr funktioniert. Folgendes hätte auch geschrieben werden können $ SA = (\text{in.münze} \rightarrow \text{out.schokolade} \rightarrow STOP) $. Die Klammern können somit weggelassen werden und der Prozess kann benannt werden.

\subsubsection{Rekursion}
Um nicht den gesamten Ablauf einen Prozesses modellieren zu müssen gibt es Rekursion. Der nicht terminierende Automat \textit{SA} würde wie folgt aussehen:
\begin{addmargin}[1cm]{0cm}
$SA = (\text{in.münze} \rightarrow \text{out.schokolade} \rightarrow SA)$
\end{addmargin}

Das zweite Beispiel eines kopierenden Automaten (\textit{COPY}) sähe wie folgt aus:

\begin{addmargin}[1cm]{0cm}
$COPY = (\text{in?x} \rightarrow \text{out!x} \rightarrow COPY)$
\end{addmargin}

\subsubsection{Parallelität}
\comment{Umschreiben: Ist Kernelement wirklich die parallele Ausführung von mehreren Prozessen?}
Momentan kann die vorgestellte Notation nur einen Prozess ausführen. Jedoch ist das Kernelement von \ac{CSP} die gleichzeitige Ausführung von Prozessen. Bei der gleichzeitigen Ausführung werden Events, die in beiden Alphabeten vorkommen synchron ausgeführt und Events, die nur in einem Prozess vorkommen von dem anderen Prozess ignoriert. Der Operator, der Prozesse parallel ausführt ist der ||-Operator. Definieren wir nun zwei Prozesse.

\begin{addmargin}[1cm]{0cm}
$mensa:SA = \mu X \bullet (\text{in.münze} \rightarrow \text{out.schokolade} \rightarrow X)$\\\\
$student:KUNDE = \mu X \bullet (\text{geldzählen} \rightarrow \text{mensa.in.münze} \rightarrow \text{mensa.out.schokolade} \rightarrow  X)$\\\\
$ (mensa:SA) || (student:KUNDE) $
\end{addmargin}

Der erste Prozess ist der bekannte Schokoladenautomat. Nun ist es aber eine genaue Instanz mit dem Namen \textit{mensa}. $\mu X$ definiert eine Funktion mit dem Bezeichner X, die dann dem Prozess \textit{SA} zugewiesen wird.
Der zweite Prozess ist ein Kunde mit dem Namen \textit{stundent}, der den Schokoladenautomat bedient. Er benutzt die Channels (Münzeinwurf, Ausgabe) des Schokoladenautomaten und zählt am Anfang sein Geld. Um beide Prozesse nun parallel auszuführen, kommt der oben angesprochene ||-Operator ins Spiel, der das ermöglicht.

\comment{Evt die Umwandlung von 2 Parallelen Prozessen in einen Prozess Zeigen. Wäre interessant im Bezug auf die Statemachine}

\subsubsection{Weitere wichtige Konstrukte}
Die oben vorgestellten Konstrukte reichen aus um einen einfachen Automaten zu definieren, der immer den gleichen Ablauf hat. Jedoch werden bei komplexeren Algorithmen Verzweigungen benötigt, um alternative Abläufe zu modellieren. Hierfür definiert die Notation den |-Operator.

\subsection{Umsetzung der Konstrukte in \CA}
In \CA\ ist ein Prozess eine Sequenz von verschiedenen Befehlen, die entweder durch einen Thread ausgeführt werden können oder in einem \textit{go}-Block in einen Zustandsautomat umgewandelt werden.

Die Kommunikation zwischen mehreren Prozessen funktioniert mit Channels, die mit der Funktion \textit{chan} erzeugt werden können. Das Hineinlegen eines Wertes (Event) wird in der Notation nicht vom Herausnehmen unterschieden, außer das Event soll zwischengespeichert werden, dann gibt es die oben erklärten Operatoren (? und !). In \CA\ wird das Hineinlegen eines Werts in einen Channel wird mit den Funktionen \textit{>!!} (bei der Verwendung von Threads) oder \textit{>!} (in einem \textit{go}-Block) gemacht und das Herausnehmen eines Werts aus dem Channel mit den Funktionen \textit{<!!} und \textit{<!} realisiert.

Alle übrigen Konstrukte, wie Rekursion, Verkettung, Verzweigungen etc. werden durch Clojure bzw. \acl{CLJS} abgebildet.