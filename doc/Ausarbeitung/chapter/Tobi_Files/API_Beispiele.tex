\section{\acs{API} Code-Beispiele}
Dieses Kapitel demonstriert die Basis-Funktionalität des Frameworks anhand von Code-Beispielen. Zwecks Vereinfachung der Beispiele wird Eingangs die Funktion \textit{read-chan} aus Listing \ref{lst:readchan}\ definiert, die eine einheitliche Ausgabe der Werte auf dem ihr übergebenen Channel realisiert. Diese Funktion durchläuft mit \textit{loop} und \textit{recur} solange alle Werte auf einem Channel, bis dieser geschlossen wird. Das Schließen des Kanals wird durch die Publikation des Wertes \textit{nil} signalisiert.
\begin{lstlisting}[language=Clojure,caption=\textit{read-chan} Hilfsfunktion,label=lst:readchan]
(defn read-chan
  ([c] (read-chan "" c))
  ([str c]
  (thread
    (loop [val (<!! c)]
      (when (not= val nil)
        (println str val)
        (recur (<!! c))))
      (println "END."))))
\end{lstlisting}
\subsection{\textit{Go}-Blocks}
Das folgende Code Beispiel aus Listing \ref{lst:goblock}\ demonstriert den Parking-Mechanismus. Zu Beginn wird  ein ungepufferter Channel \textit{c} erzeugt. Anschließend wird mittels \textit{>!} und \textit{<!} in Kombination mit \textit{go} darauf zugegriffen. Ist der Channel belegt, so wird die \textit{>!} Funktion geparkt. Ein ähnliches Verhalten ist bei \textit{<!} erkennbar, welche geparkt wird, wenn kein Wert auf dem Channel vorliegt. Ist ein Wert vorhanden, so wird dieser vom Channel entfernt und auf der Konsole ausgegeben.
\begin{lstlisting}[language=Clojure,caption=\textit{Go}-Blocks,label=lst:goblock]
(let [c (chan)]
  (go
    (>! c "test"))
  (go
    (println (<! c))))
\end{lstlisting}
\subsection{Threads}
Das obige Beispiel aus Listing \ref{lst:goblock}\ lässt sich auch mit blockierenden Funktionen in Threads ausführen. Die Korrelate zu den Put- und Take-Operation sind hier \textit{>!!} und \textit{<!!}, welche den jeweiligen Thread, in dem sie ausgeführt werden beim Lesen bzw. Schreiben blockieren (siehe Listing \ref{lst:thread}).
\begin{lstlisting}[language=Clojure,caption=Thread,label=lst:thread]
(let [c (chan)]
  (thread
    (>!! c "test"))
  (thread
    (println (<!! c))))
\end{lstlisting}
\subsection{Timeout}
Channels lassen sich in ihrer Lebensdauer zeitlich beschränken, indem man ihre Erzeugung mit Hilfe der \textit{timeout}-Funktion vornimmt. Diese Kanäle werden nach Ablauf des Timeouts automatisch geschlossen. Das folgende Beispiel aus Listing \ref{lst:timeout} demonstriert dieses Verhalten:\\
Zu Beginn wird ein Channel mittels \textit{timeout} erzeugt und neuer Wert asynchron mit Hilfe von \textit{put!} darauf abgelegt. In einem Thread werden nun, wie in der Funktion \textit{read-chan} aus Listing {lst:readchan}\ solange Werte vom Channel abgerufen, bis dieser seine Schließung mittels \textit{nil}-Wert signalisiert.
\begin{lstlisting}[language=Clojure,caption=Timeout,label=lst:timeout]
(let [c (timeout 4000)]
  (put! c "test")
  (thread
  (loop [val (<!! c)]
    (when (not= val nil)
      (println val)
      (recur (<!! c))))
    (println "timeout")))
\end{lstlisting}
\subsection{Filter}
\begin{lstlisting}[language=Clojure,caption=Filter,label=lst:filter]
(let [out (chan)
      c (filter> string? out)]
  (thread
    (>!! c "abc")
    (>!! c 123))
  (read-chan out))
\end{lstlisting}
\subsection{Buffer}
\begin{lstlisting}[language=Clojure,caption=Buffer,label=lst:buffer]
(let [c (chan (buffer 4))]
  (dotimes[n 4]
    (>!! c n))
  (dotimes[n 4]
    (println (<!! c))))
\end{lstlisting}
\acresetall
