\chapter{Zusammenfassung und Fazit}

Zu Beginn wurde erklärt, was asynchrone Programmierung bedeutet und weshalb ein nicht blockierendes \acs{I/O}-Modell hierzu benötigt wird. Diese beiden Begriffe wurden mittels JavaScript- und Clojure-Code anschaulich dargestellt. Zudem wurde das Programmierparadigma \acf{CPS}, das häufig in JavaScript zum Einsatz kommt, erläutert.\\
Zur Einführung in die Design Prinzipien von \textit{core.async} wurde das Channel- und Prozess-Prinzip aus Tony Hoare's Prozess-Algebra \acf{CSP} zur Modellierung nebenläufiger Prozesse erklärt. Es wurde gezeigt, dass \acs{CSP} eine sinnvolle Methode ist, um effizient, unter Ausschluss von  Race-Conditions, nebenläufige Modelle zu konstruieren, die von modernen Multi-Core-Prozessoren parallel ausgeführt werden können.\\
Zur Darstellung der Vor- und Nachteile von \acs{CSP}, wurde ein Vergleich zwischen diesem und dem Aktorenmodell angestellt. Das Aktorenmodell ist wie \acs{CSP} ein Prinzip zur Modellierung von Nebenläufigkeit. Es wurde festgestellt, dass keines der Modelle gegenüber dem Anderen präferiert werden kann. Der Entwickler muss nach den bestehenden Anforderungen entscheiden, welches Modell den fachlichen Anforderungen besser entspricht, so auch beim Einsatz von \textit{core.async}. Jedoch sollten auch die Unterschiede der Implementierungen in Betracht gezogen werden, die eventuelle Nachteile des theoretischen Modells aufwiegen.\\
Das darauffolgende Kapitel dieser Ausarbeitung, befassten sich mit der Darstellung der Basis-Funktionalität der \acs{API} von \textit{core.async}, die mit Code-Beispielen demonstriert wurde. Die Bibliothek wirkt sehr stabil. Der Umfang der \acs{API} ist für eine Version im Alpha-Stadium beachtlich und kann bereits jetzt produktiv in kleineren Projekten eingesetzt werden. Es ist hervorzuheben, dass - ausgenommen Thread-basierter Konstrukte - \textit{core.async} kompatibel zu ClojureScript ist und der Clojure-Code demnach zu JavaScript kompiliert werden kann. Dies erleichtert die Modellierung von Quasi-Parallelen (single threaded) Prozessen in JavaScript erheblich und schafft neue Möglichkeiten.\\
Dieses Projekt hat uns tiefe Einblicke in diverse hochinteressante Programmierparadigmen zur Modellierung von Nebenläufigkeit und Parallelität gewährt und uns persönlich weiter gebracht.



